<?php


namespace Zan\DoctrineRestBundle\Controller;


use Zan\CommonBundle\Util\RequestUtils;
use Zan\CommonBundle\Util\ZanAnnotation;
use Zan\CommonBundle\Util\ZanArray;
use Zan\DoctrineRestBundle\Annotation\HumanReadableId;
use Zan\DoctrineRestBundle\EntityResultSet\AbstractEntityResultSet;
use Zan\DoctrineRestBundle\EntityResultSet\GenericEntityResultSet;
use Zan\DoctrineRestBundle\EntitySerializer\MinimalEntitySerializer;
use Zan\DoctrineRestBundle\Loader\ApiEntityLoader;
use Zan\DoctrineRestBundle\Permissions\PermissionsCalculatorFactory;
use Zan\DoctrineRestBundle\Permissions\ResultSetEditabilityMap;
use Doctrine\Common\Annotations\Reader;
use Doctrine\ORM\EntityManager;
use Doctrine\ORM\EntityManagerInterface;
use Doctrine\ORM\Mapping\Id;
use Doctrine\ORM\Query\Expr\Base;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

/**
 * @Route("/entity")
 */
class EntityDataController extends AbstractController
{
    /**
     * @Route("/{entityId}")
     */
    public function listEntities(
        string $entityId,
        Request $request,
        EntityManager $em,
        Reader $annotationReader,
    ) {
        $params = RequestUtils::getParameters($request);
        $responseFields = [];
        $includeMetadata = [];

        $entityClassName = $this->unescapeEntityId($entityId);
        $permissionsCalculatorFactory = new PermissionsCalculatorFactory($em);
        $permissionsCalculator = $permissionsCalculatorFactory->getPermissionsCalculator($entityClassName);

        if ($request->query->has('includeMetadata')) {
            $includeMetadata = ZanArray::createFromString($params['includeMetadata']);
        }
        if ($request->query->has('responseFields')) {
            $responseFields = ZanArray::createFromString($params['responseFields']);
        }

        $resultSet = new GenericEntityResultSet(
            $em,
            $entityClassName
        );
        $resultSet->setActingUser($this->getUser());

        $entitySerializer = new MinimalEntitySerializer(
            $em,
            $annotationReader
        );

        $entities = [];
        $metadata = [];

        $editabilityMap = null;
        $includeEditability = false;
        if (in_array('editability', $includeMetadata)) {
            $includeEditability = true;
            $editabilityMap = new ResultSetEditabilityMap(
                $permissionsCalculator,
                $this->getUser()
            );
        }
        // todo: implement canCreateEntity

        // Process results
        foreach ($resultSet->getResults() as $entity) {
            $entities[] = $entitySerializer->serialize($entity, $responseFields);

            if ($includeEditability) {
                $editabilityMap->processEntity($entity);
            }
        }

        if ($includeEditability) {
            $metadata['editability'] = $editabilityMap->getCompressedMap();
        }

        return new JsonResponse([
            'success' => true,
            'data' => $entities,
            'metadata' => $metadata,
        ]);
    }

    /**
     * @Route("/{entityId}/{identifier}")
     */
    public function getEntity(
        string $entityId,
        string $identifier,
        Request $request,
        EntityManagerInterface $em,
        Reader $annotationReader,
    ) {
        $params = RequestUtils::getParameters($request);
        $entityClassName = $this->unescapeEntityId($entityId);

        $responseFields = [];

        if ($request->query->has('responseFields')) {
            $responseFields = ZanArray::createFromString($params['responseFields']);
        }

        // Identifier in the query string overrides one in the route
        // ExtJs will start with an autogenerated ID but extraparams can be used to pass an
        // explicit identifier, so one in the query string should take precedence
        if ($request->query->has('identifier')) {
            $identifier = $request->query->get('identifier');
        }

        $resultSet = new GenericEntityResultSet($em, $entityClassName);
        $resultSet->setActingUser($this->getUser());

        // Apply identifier filter
        $this->applyIdentifierFilter($resultSet, $identifier, $em, $annotationReader);

        // todo: escaping + parameter handling
        //$resultSet->addFilterDql('e = ' . $identifier);

        $entity = $resultSet->mustGetSingleResult();

        $serializer = new MinimalEntitySerializer(
            $em,
            $annotationReader,
        );

        $serialized = $serializer->serialize($entity, $responseFields);

        $retData = [
            'success' => true,
            'data' => $serialized,
        ];

        return new JsonResponse($retData);
    }

    protected function applyIdentifierFilter(
        GenericEntityResultSet $resultSet,
        $identifier,
        EntityManagerInterface $em,
        Reader $annotationReader,
    ) {
        $expr = $em->getExpressionBuilder();

        $identifiersExpr = new Orx();

        foreach ($resultSet->getEntityProperties() as $property) {
            $hasDoctrineId = ZanAnnotation::hasPropertyAnnotation(
                $annotationReader,
                Id::class,
                $resultSet->getEntityClassName(),
                $property->name
            );

            $hasZanHumanReadableId = ZanAnnotation::hasPropertyAnnotation(
                $annotationReader,
                HumanReadableId::class,
                $resultSet->getEntityClassName(),
                $property->name
            );

            if ($hasDoctrineId || $hasZanHumanReadableId) {
                $identifiersExpr->add($expr->eq('e.' . $property->name, ':identifier'));
            }
        }

        $resultSet->addFilterExpr($identifiersExpr);
        $resultSet->setDqlParameter('identifier', $identifier);
    }

    /**
     * @Route("/{entityId}/{identifier}", methods="PUT")
     */
    public function updateEntity(Request $request, string $entityId, string $identifier)
    {
        $em = $this->get('doctrine.orm.entity_manager');
        $entityClassName = $this->unescapeEntityId($entityId);

        $permissionsCalculatorFactory = new PermissionsCalculatorFactory($em);
        $permissionsCalculator = $permissionsCalculatorFactory->getPermissionsCalculator($entityClassName);

        $entityLoader = new ApiEntityLoader($em, $this->getUser());
        $entityLoader->setPermissionsCalculator($permissionsCalculator);

        $serializer = new MinimalEntitySerializer(
            $this->get('doctrine.orm.entity_manager'),
            $this->get('annotation_reader')
        );

        $entity = $em->find($entityClassName, $identifier);
        if (!$entity) throw new \InvalidArgumentException("No entity found with the specified identifier");

        // Deny access unless there's a calculator that specifically permits access
        if (!$permissionsCalculator || !$permissionsCalculator->canEditEntity($entity, $this->getUser())) {
            // todo: better exceptions here and when not found
            throw new \InvalidArgumentException('User does not have permissions to edit entity');
        }

        $decodedBody = json_decode($request->getContent(), true);
        $entityLoader->load($entity, $decodedBody);

        // Commit changes to the database
        $em->flush();

        $retData = [
            'success',
            'data' => $serializer->serialize($entity),
        ];

        return new JsonResponse($retData);
    }

    /**
     * @Route("/{entityId}", methods="POST")
     */
    public function createEntity(Request $request, string $entityId)
    {
        $em = $this->get('doctrine.orm.entity_manager');
        $entityClassName = $this->unescapeEntityId($entityId);

        $permissionsCalculatorFactory = new PermissionsCalculatorFactory($em);
        $permissionsCalculator = $permissionsCalculatorFactory->getPermissionsCalculator($entityClassName);

        $entityLoader = new ApiEntityLoader($em, $this->getUser());
        $entityLoader->setPermissionsCalculator($permissionsCalculator);

        $serializer = new MinimalEntitySerializer(
            $this->get('doctrine.orm.entity_manager'),
            $this->get('annotation_reader')
        );

        // Deny access unless there's a calculator that specifically permits access
        if (!$permissionsCalculator || !$permissionsCalculator->canCreateEntity($entityClassName, $this->getUser())) {
            // todo: better exception here
            throw new \InvalidArgumentException('User does not have permissions to create entity');
        }

        $decodedBody = json_decode($request->getContent(), true);
        $newEntity = $entityLoader->create($entityClassName, $decodedBody);

        // Commit changes to the database
        $em->persist($newEntity);
        $em->flush();

        $retData = [
            'success',
            'data' => $serializer->serialize($newEntity),
        ];

        return new JsonResponse($retData);
    }

    protected function unescapeEntityId($escapedEntityId)
    {
        return str_replace('.', '\\', $escapedEntityId);
    }
}